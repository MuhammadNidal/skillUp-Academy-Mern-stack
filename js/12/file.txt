ğŸ’¡ JavaScript Scope, Lexical Scope, and Closures â€” Full Easy Guide
ğŸ§  1. What is Scope?

Scope = Where your variable can be used or accessed.

There are 2 main types:

âœ… Global Scope

A variable declared outside any function or block.

let name = "Nidal"; // Global

function sayName() {
  console.log(name); // âœ… Accessible
}

sayName();
console.log(name); // âœ… Accessible


â¡ï¸ Can be accessed from anywhere.

âœ… Local Scope

A variable declared inside a function or block {}.

function greet() {
  let message = "Hello"; // Local
  console.log(message); // âœ… Accessible here
}

greet();
console.log(message); // âŒ Not accessible outside


â¡ï¸ Can be accessed only inside the same block or function.

ğŸ§­ 2. Lexical Scope (Static Scope)

Lexical Scope =
â¡ï¸ Where your function is written (defined), not where it is called.

So an inner function can access the variables of its outer function,
because it is written inside that outer function.

function outer() {
  let outerVar = "Iâ€™m outer";

  function inner() {
    console.log(outerVar); // âœ… Works (lexical scope)
  }

  inner();
}

outer();


ğŸ’¬ Even though inner() doesnâ€™t define outerVar,
it can still use it because itâ€™s written inside outer().

ğŸ”’ 3. Closure

A closure happens when a function remembers variables from the place it was created,
even after that outer function is finished.

Example:

function counter() {
  let count = 0;

  return function () {
    count++; // inner function using outer variable
    console.log(count);
  };
}

const myCounter = counter(); // counter() finished, but closure remembers 'count'

myCounter(); // 1
myCounter(); // 2
myCounter(); // 3


ğŸ§  The inner function still â€œremembersâ€ count â€” thatâ€™s a closure!

âš–ï¸ Lexical Scope vs Closure â€” Easy Difference
Feature	Lexical Scope	Closure
Meaning	Defines what variables a function can access based on where it is written.	Happens when a function remembers variables from its parent scope even after the parent is done.
When it works	Always (static rule decided at code creation).	Only when a function is returned or passed and used later.
Focus	Access of variables.	Remembering variables.
Example Use	Nested functions reading parent vars.	Returning functions that keep private data.
Simple Line	â€œWhereâ€ a function can see variables.	â€œRememberingâ€ those variables later.
ğŸ§° Example Showing Both Together
function outer() {
  let outerVar = "Outer variable";

  function inner() {
    console.log(outerVar); // âœ… Lexical Scope
  }

  return inner; // ğŸ”’ Returning function creates a Closure
}

const myFunc = outer(); // outer() runs, finishes
myFunc(); // inner() still remembers outerVar (Closure)


ğŸ§© Lexical Scope: allows inner() to see outerVar.
ğŸ”’ Closure: allows inner() to remember outerVar even after outer() has finished.

ğŸª„ Quick Summary (Easy to Remember)
Concept	Quick Meaning	Example
Global Scope	Accessible everywhere	let x = 10;
Local Scope	Accessible only inside function/block	function test(){ let y=5; }
Lexical Scope	Inner can access outer vars	Nested functions
Closure	Function remembers outer vars after parent ends	Returning inner function